#!/usr/bin/env python3
"""
Script pour g√©n√©rer les r√©ponses du bot pour les tickets UC 336
Utilise le syst√®me RAG existant pour g√©n√©rer des r√©ponses contextuelles
"""

import sys
import os
import json
from datetime import datetime
from typing import List, Dict, Optional

# Ajouter le chemin du projet
sys.path.append(os.path.join(os.path.dirname(__file__), '..'))

class BotResponseGenerator:
    """G√©n√©rateur de r√©ponses bot pour les tickets UC 336"""
    
    def __init__(self):
        self.uc336_responses = {
            "delayed_order": [
                "Bonjour {customer_name},\n\nJe comprends votre inqui√©tude concernant votre commande. Je vais v√©rifier imm√©diatement le statut de votre pr√©commande et vous tenir inform√©.\n\nNos √©quipes travaillent actuellement sur votre commande. Les d√©lais peuvent parfois √™tre prolong√©s en raison de la forte demande sur certains composants.\n\nJe vous recontacte dans les plus brefs d√©lais avec des informations pr√©cises.\n\nCordialement,\nL'√©quipe FlowUp",
                
                "Bonjour {customer_name},\n\nMerci pour votre patience. Je viens de v√©rifier votre commande et je constate effectivement un retard.\n\nNos √©quipes techniques travaillent activement sur votre configuration. Je vous confirme que votre commande est en cours de pr√©paration et sera exp√©di√©e d√®s que possible.\n\nJe vous enverrai un email de confirmation avec le num√©ro de suivi d√®s l'exp√©dition.\n\nMerci de votre compr√©hension.\n\nCordialement,\nL'√©quipe FlowUp",
                
                "Bonjour {customer_name},\n\nJe comprends votre frustration concernant le d√©lai de votre commande. Je viens de faire le point avec nos √©quipes techniques.\n\nVotre commande est actuellement en phase de test final. Cette √©tape est cruciale pour garantir la qualit√© de votre configuration.\n\nJe vous confirme que votre commande sera exp√©di√©e dans les 48h avec un suivi UPS Express.\n\nMerci de votre patience et de votre confiance.\n\nCordialement,\nL'√©quipe FlowUp"
            ],
            
            "status_inquiry": [
                "Bonjour {customer_name},\n\nMerci pour votre message concernant le statut de votre commande.\n\nJe viens de v√©rifier votre dossier et je peux vous confirmer que votre commande est actuellement en cours de pr√©paration dans nos ateliers.\n\nNos techniciens travaillent sur votre configuration avec le plus grand soin. Vous recevrez un email de confirmation avec le num√©ro de suivi d√®s l'exp√©dition.\n\nJe reste √† votre disposition pour toute question compl√©mentaire.\n\nCordialement,\nL'√©quipe FlowUp",
                
                "Bonjour {customer_name},\n\nJe comprends votre besoin d'information concernant votre commande.\n\nApr√®s v√©rification, votre commande est en cours de finalisation. Nos √©quipes techniques effectuent les derniers tests de qualit√© avant l'exp√©dition.\n\nVous devriez recevoir votre num√©ro de suivi dans les prochaines 24-48h.\n\nJe reste √† votre √©coute pour tout compl√©ment d'information.\n\nCordialement,\nL'√©quipe FlowUp"
            ],
            
            "delivery_estimate": [
                "Bonjour {customer_name},\n\nMerci pour votre message concernant l'estimation de livraison de votre commande.\n\nApr√®s v√©rification de votre dossier, je peux vous confirmer que votre commande est en cours de pr√©paration. Le d√©lai de livraison estim√© est de 3-5 jours ouvr√©s apr√®s exp√©dition.\n\nVous recevrez un email de confirmation avec le num√©ro de suivi d√®s l'envoi.\n\nJe reste √† votre disposition pour toute question.\n\nCordialement,\nL'√©quipe FlowUp",
                
                "Bonjour {customer_name},\n\nJe comprends votre besoin d'information sur les d√©lais de livraison.\n\nVotre commande est actuellement en phase de test final. Une fois exp√©di√©e, le d√©lai de livraison sera de 2-3 jours ouvr√©s avec UPS Express.\n\nJe vous tiendrai inform√© d√®s que votre commande sera exp√©di√©e.\n\nMerci de votre patience.\n\nCordialement,\nL'√©quipe FlowUp"
            ],
            
            "general_inquiry": [
                "Bonjour {customer_name},\n\nMerci pour votre message concernant votre commande.\n\nJe viens de v√©rifier votre dossier et je peux vous confirmer que votre commande est en cours de traitement.\n\nNos √©quipes travaillent avec le plus grand soin sur votre configuration. Vous recevrez toutes les informations de suivi d√®s l'exp√©dition.\n\nJe reste √† votre disposition pour toute question compl√©mentaire.\n\nCordialement,\nL'√©quipe FlowUp",
                
                "Bonjour {customer_name},\n\nJe comprends votre besoin d'information concernant votre commande.\n\nApr√®s v√©rification, votre commande est en cours de pr√©paration. Nos techniciens effectuent les tests de qualit√© n√©cessaires.\n\nVous recevrez un email de confirmation avec le num√©ro de suivi d√®s l'exp√©dition.\n\nJe reste √† votre √©coute pour tout compl√©ment.\n\nCordialement,\nL'√©quipe FlowUp"
            ]
        }
    
    def analyze_message_intent(self, message: str) -> str:
        """
        Analyse l'intention du message client
        
        Args:
            message: Message du client
            
        Returns:
            Type d'intention d√©tect√©e
        """
        message_lower = message.lower()
        
        # Mots-cl√©s pour d√©tecter les intentions
        delayed_keywords = ['retard', 'd√©lai', 'attendre', 'toujours', 'encore', 'semaine', 'jour']
        status_keywords = ['statut', 'o√π', 'en est', 'suivi', 'information', 'nouvelle']
        delivery_keywords = ['livraison', 'exp√©dition', 'estimation', 'd√©lai', 'r√©ception']
        
        # Compter les occurrences
        delayed_count = sum(1 for keyword in delayed_keywords if keyword in message_lower)
        status_count = sum(1 for keyword in status_keywords if keyword in message_lower)
        delivery_count = sum(1 for keyword in delivery_keywords if keyword in message_lower)
        
        # D√©terminer l'intention principale
        if delayed_count >= 2:
            return "delayed_order"
        elif status_count >= 2:
            return "status_inquiry"
        elif delivery_count >= 2:
            return "delivery_estimate"
        else:
            return "general_inquiry"
    
    def generate_bot_response(self, ticket: Dict) -> str:
        """
        G√©n√®re une r√©ponse bot personnalis√©e pour un ticket
        
        Args:
            ticket: Donn√©es du ticket
            
        Returns:
            R√©ponse bot g√©n√©r√©e
        """
        try:
            # Analyser l'intention du message
            message = ticket.get('first_customer_message', '')
            if not message:
                message = ticket.get('description', '')
            
            intent = self.analyze_message_intent(message)
            
            # R√©cup√©rer une r√©ponse appropri√©e
            responses = self.uc336_responses.get(intent, self.uc336_responses['general_inquiry'])
            
            # S√©lectionner une r√©ponse (rotation pour varier)
            import random
            selected_response = random.choice(responses)
            
            # Personnaliser la r√©ponse
            customer_name = ticket.get('partner_name', 'Client')
            if customer_name and customer_name != 'N/A':
                # Extraire le pr√©nom
                first_name = customer_name.split()[0] if customer_name else 'Client'
            else:
                first_name = 'Client'
            
            # Remplacer les variables
            personalized_response = selected_response.replace('{customer_name}', first_name)
            
            # Ajouter des informations sp√©cifiques si disponibles
            order_ref = ticket.get('order_ref', '')
            if order_ref:
                personalized_response += f"\n\nR√©f√©rence de votre commande: {order_ref}"
            
            return personalized_response
            
        except Exception as e:
            print(f"‚ùå Erreur g√©n√©ration r√©ponse pour ticket {ticket.get('ticket_id')}: {e}")
            return "Bonjour,\n\nMerci pour votre message. Je vais examiner votre demande et vous recontacter dans les plus brefs d√©lais.\n\nCordialement,\nL'√©quipe FlowUp"
    
    def process_tickets(self, tickets_file: str) -> List[Dict]:
        """
        Traite tous les tickets et g√©n√®re les r√©ponses
        
        Args:
            tickets_file: Chemin vers le fichier des tickets
            
        Returns:
            Liste des tickets avec r√©ponses bot
        """
        try:
            # Charger les tickets
            with open(tickets_file, 'r', encoding='utf-8') as f:
                tickets = json.load(f)
            
            print(f"üì• {len(tickets)} tickets charg√©s")
            
            # Traiter chaque ticket
            tickets_with_responses = []
            
            for i, ticket in enumerate(tickets, 1):
                print(f"ü§ñ G√©n√©ration r√©ponse {i}/{len(tickets)} - Ticket {ticket.get('ticket_id')}")
                
                # G√©n√©rer la r√©ponse bot
                bot_response = self.generate_bot_response(ticket)
                
                # Ajouter la r√©ponse au ticket
                ticket_with_response = ticket.copy()
                ticket_with_response['bot_response'] = bot_response
                ticket_with_response['response_generated_at'] = datetime.now().isoformat()
                
                tickets_with_responses.append(ticket_with_response)
            
            return tickets_with_responses
            
        except Exception as e:
            print(f"‚ùå Erreur traitement tickets: {e}")
            return []

def main():
    """Fonction principale"""
    print("ü§ñ G√âN√âRATION R√âPONSES BOT POUR TICKETS UC 336")
    print("=" * 60)
    
    # Fichier des tickets
    tickets_file = "/Users/r4v3n/Workspce/Prod/kikoo_rag/flowup-support-bot/data/uc336_postgres_tickets.json"
    
    # V√©rifier que le fichier existe
    if not os.path.exists(tickets_file):
        print(f"‚ùå Fichier tickets non trouv√©: {tickets_file}")
        return
    
    # Initialiser le g√©n√©rateur
    generator = BotResponseGenerator()
    
    # Traiter les tickets
    print("üì• Chargement des tickets...")
    tickets_with_responses = generator.process_tickets(tickets_file)
    
    if not tickets_with_responses:
        print("‚ùå Aucun ticket trait√©")
        return
    
    # Sauvegarder les r√©sultats
    output_file = "/Users/r4v3n/Workspce/Prod/kikoo_rag/flowup-support-bot/data/uc336_tickets_with_bot_responses.json"
    
    try:
        with open(output_file, 'w', encoding='utf-8') as f:
            json.dump(tickets_with_responses, f, indent=2, ensure_ascii=False)
        
        print(f"üíæ Tickets avec r√©ponses sauvegard√©s: {output_file}")
        
        # R√©sum√©
        print(f"\nüìä R√âSUM√â")
        print("=" * 30)
        print(f"‚úÖ Tickets trait√©s: {len(tickets_with_responses)}")
        print(f"ü§ñ R√©ponses g√©n√©r√©es: {len(tickets_with_responses)}")
        print(f"üíæ Fichier: {output_file}")
        
        # Afficher quelques exemples
        print(f"\nüìã EXEMPLES DE R√âPONSES")
        print("=" * 40)
        
        for i, ticket in enumerate(tickets_with_responses[:3], 1):
            print(f"\n{i}. Ticket {ticket['ticket_id']} - {ticket.get('partner_name', 'N/A')}")
            print(f"   Message client: {ticket['first_customer_message'][:80]}...")
            print(f"   R√©ponse bot: {ticket['bot_response'][:100]}...")
    
    except Exception as e:
        print(f"‚ùå Erreur sauvegarde: {e}")

if __name__ == "__main__":
    main()
