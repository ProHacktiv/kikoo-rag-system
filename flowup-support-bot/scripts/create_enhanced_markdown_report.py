#!/usr/bin/env python3
"""
Script pour cr√©er le rapport Markdown final avec les r√©ponses bot am√©lior√©es
"""

import sys
import os
import json
from datetime import datetime
from typing import List, Dict

# Ajouter le chemin du projet
sys.path.append(os.path.join(os.path.dirname(__file__), '..'))

class EnhancedMarkdownReportGenerator:
    """G√©n√©rateur de rapport Markdown am√©lior√© avec escalade"""
    
    def __init__(self):
        self.report_sections = []
    
    def create_header(self) -> str:
        """Cr√©e l'en-t√™te du rapport"""
        return f"""# üö® RAPPORT TICKETS UC 336 - ESCALADES IMM√âDIATES

## üìä Informations G√©n√©rales

- **Date de g√©n√©ration** : {datetime.now().strftime('%d/%m/%Y %H:%M:%S')}
- **Type de tickets** : UC 336 (Statut pr√©commande)
- **P√©riode** : Janvier 2024 - Septembre 2025
- **Source** : Base de donn√©es PostgreSQL FlowUp RAG
- **Nombre de tickets** : 10
- **Escalades imm√©diates** : 10/10 üö®
- **Seuil l√©gal** : 12 jours

---

## ‚ö†Ô∏è ALERTE CRITIQUE

**TOUS LES TICKETS N√âCESSITENT UNE ESCALADE IMM√âDIATE**

- D√©lai l√©gal d√©pass√© sur 100% des tickets
- Retard moyen : 27 jours (vs 12 jours l√©gal)
- Actions imm√©diates requises pour chaque ticket

---

## üéØ Objectif

Ce rapport pr√©sente 10 tickets UC 336 avec des retards critiques n√©cessitant une escalade imm√©diate. Chaque ticket a √©t√© analys√© par le syst√®me IA qui a d√©tect√© des d√©lais d√©passant le seuil l√©gal de 12 jours.

Le chatbot s'est pr√©sent√©, a r√©cup√©r√© les donn√©es, calcul√© les d√©lais et d√©clench√© l'escalade automatique.

---

"""
    
    def create_ticket_section(self, ticket: Dict, index: int) -> str:
        """Cr√©e une section pour un ticket avec escalade"""
        
        # Informations du ticket
        ticket_id = ticket.get('ticket_id', 'N/A')
        ticket_name = ticket.get('ticket_name', 'N/A')
        create_date = ticket.get('create_date', 'N/A')
        partner_name = ticket.get('partner_name', 'N/A')
        partner_email = ticket.get('partner_email', 'N/A')
        priority = ticket.get('priority', 'N/A')
        stage = ticket.get('stage', 'N/A')
        team = ticket.get('team', 'N/A')
        order_ref = ticket.get('order_ref', 'N/A')
        tracking_ref = ticket.get('tracking_ref', 'N/A')
        
        # Donn√©es d'escalade
        days_since_order = ticket.get('days_since_order', 0)
        escalation_info = ticket.get('escalation_info', {})
        needs_escalation = escalation_info.get('needs_immediate_escalation', False)
        urgency_level = escalation_info.get('urgency_level', 'NORMAL')
        escalation_reason = escalation_info.get('escalation_reason', '')
        escalation_actions = escalation_info.get('escalation_actions', [])
        
        # Messages
        first_message = ticket.get('first_customer_message', 'Aucun message disponible')
        bot_response = ticket.get('bot_response_enhanced', 'Aucune r√©ponse g√©n√©r√©e')
        
        # Donn√©es IA
        ai_problem_resume = ticket.get('ai_problem_resume', 'N/A')
        ai_emotions_detectees = ticket.get('ai_emotions_detectees', 'N/A')
        ai_urgency_indicators = ticket.get('ai_urgency_indicators', 'N/A')
        ai_real_priority = ticket.get('ai_real_priority', 'N/A')
        
        # Statut d'escalade
        escalation_status = "üö® ESCALADE IMM√âDIATE" if needs_escalation else "‚úÖ Normal"
        urgency_icon = "üö®" if urgency_level == "CRITICAL" else "‚ö†Ô∏è" if urgency_level == "HIGH" else "üìã" if urgency_level == "MEDIUM" else "‚úÖ"
        
        return f"""## {urgency_icon} Ticket #{index} - ID: {ticket_id} - {escalation_status}

### üìã Informations du Ticket

| Champ | Valeur |
|-------|--------|
| **ID Ticket** | {ticket_id} |
| **Nom** | {ticket_name} |
| **Date de cr√©ation** | {create_date} |
| **Client** | {partner_name} |
| **Email** | {partner_email} |
| **Priorit√©** | {priority} |
| **Statut** | {stage} |
| **√âquipe** | {team} |
| **R√©f√©rence commande** | {order_ref} |
| **Num√©ro de suivi** | {tracking_ref} |

### üö® Analyse d'Escalade

| Champ | Valeur |
|-------|--------|
| **D√©lai √©coul√©** | {days_since_order} jours |
| **Seuil l√©gal** | 12 jours |
| **D√©passement** | {days_since_order - 12} jours |
| **Statut escalade** | {escalation_status} |
| **Niveau d'urgence** | {urgency_level} |
| **Raison escalade** | {escalation_reason} |

### üîß Actions d'Escalade

{chr(10).join(f"- {action}" for action in escalation_actions) if escalation_actions else "- Aucune action d√©finie"}

### ü§ñ Analyse IA

| Champ | Valeur |
|-------|--------|
| **R√©sum√© du probl√®me** | {ai_problem_resume} |
| **√âmotions d√©tect√©es** | {ai_emotions_detectees} |
| **Indicateurs d'urgence** | {ai_urgency_indicators} |
| **Priorit√© r√©elle** | {ai_real_priority} |

### üí¨ Conversation

#### üë§ Message du Client

```
{first_message}
```

#### ü§ñ R√©ponse du Bot (avec Escalade)

```
{bot_response}
```

---

"""
    
    def create_escalation_summary(self, tickets: List[Dict]) -> str:
        """Cr√©e un r√©sum√© des escalades"""
        
        # Statistiques
        total_tickets = len(tickets)
        immediate_escalations = sum(1 for t in tickets if t.get('escalation_info', {}).get('needs_immediate_escalation', False))
        high_urgency = sum(1 for t in tickets if t.get('escalation_info', {}).get('urgency_level') == 'HIGH')
        medium_urgency = sum(1 for t in tickets if t.get('escalation_info', {}).get('urgency_level') == 'MEDIUM')
        normal_urgency = sum(1 for t in tickets if t.get('escalation_info', {}).get('urgency_level') == 'NORMAL')
        
        # Calculs de d√©lais
        days_list = [t.get('days_since_order', 0) for t in tickets]
        avg_delay = sum(days_list) / len(days_list) if days_list else 0
        max_delay = max(days_list) if days_list else 0
        min_delay = min(days_list) if days_list else 0
        
        return f"""
## üìä R√âSUM√â DES ESCALADES

### üö® Statistiques Critiques

| M√©trique | Valeur |
|----------|--------|
| **Total tickets** | {total_tickets} |
| **Escalades imm√©diates** | {immediate_escalations} ({immediate_escalations/total_tickets*100:.1f}%) |
| **Urgence √©lev√©e** | {high_urgency} |
| **Urgence moyenne** | {medium_urgency} |
| **Urgence normale** | {normal_urgency} |

### ‚è∞ Analyse des D√©lais

| M√©trique | Valeur |
|----------|--------|
| **D√©lai moyen** | {avg_delay:.1f} jours |
| **D√©lai maximum** | {max_delay} jours |
| **D√©lai minimum** | {min_delay} jours |
| **Seuil l√©gal** | 12 jours |
| **D√©passement moyen** | {avg_delay - 12:.1f} jours |

### üéØ Actions Requises

1. **Escalade imm√©diate** : {immediate_escalations} tickets
2. **Contact client** : Dans les 2h pour chaque escalade
3. **V√©rification production** : Statut urgent
4. **Compensation** : Proposition pour chaque client
5. **Suivi renforc√©** : Surveillance continue

---
"""
    
    def create_footer(self) -> str:
        """Cr√©e le pied de page du rapport"""
        return f"""
## üö® ACTIONS IMM√âDIATES REQUISES

### ‚ö†Ô∏è Priorit√© 1 - Escalades Imm√©diates

1. **Contact client** : Dans les 2h pour chaque ticket
2. **V√©rification production** : Statut urgent de chaque commande
3. **Proposition compensation** : Pour chaque client affect√©
4. **Suivi renforc√©** : Surveillance continue

### üìû Contacts d'Escalade

- **Manager Support** : Escalade imm√©diate
- **√âquipe Production** : V√©rification statut
- **Service Client** : Contact clients
- **Direction** : Information des retards

### üìã Processus d'Escalade

1. **D√©tection automatique** : Syst√®me IA
2. **Notification imm√©diate** : Manager
3. **Contact client** : Dans les 2h
4. **V√©rification production** : Statut urgent
5. **Proposition solution** : Compensation
6. **Suivi renforc√©** : Jusqu'√† r√©solution

---

## üéØ Conclusion

**SITUATION CRITIQUE D√âTECT√âE**

Le syst√®me IA a identifi√© une situation critique avec 100% des tickets n√©cessitant une escalade imm√©diate. Tous les d√©lais l√©gaux sont d√©pass√©s, n√©cessitant une intervention urgente.

**Actions imm√©diates :**
- Escalade vers le management
- Contact clients dans les 2h
- V√©rification statut production
- Proposition de compensation

Le syst√®me de d√©tection automatique fonctionne correctement et a permis d'identifier cette situation critique avant qu'elle ne s'aggrave.

---

*Rapport g√©n√©r√© automatiquement par le syst√®me FlowUp RAG - {datetime.now().strftime('%d/%m/%Y %H:%M:%S')}*
"""
    
    def generate_enhanced_report(self, tickets_file: str) -> str:
        """
        G√©n√®re le rapport Markdown am√©lior√© avec escalades
        
        Args:
            tickets_file: Chemin vers le fichier des tickets avec escalades
            
        Returns:
            Contenu du rapport Markdown
        """
        try:
            # Charger les tickets
            with open(tickets_file, 'r', encoding='utf-8') as f:
                tickets = json.load(f)
            
            print(f"üì• {len(tickets)} tickets charg√©s pour le rapport am√©lior√©")
            
            # Cr√©er le rapport
            report_content = []
            
            # En-t√™te
            report_content.append(self.create_header())
            
            # Sections pour chaque ticket
            for i, ticket in enumerate(tickets, 1):
                print(f"üìù G√©n√©ration section am√©lior√©e {i}/{len(tickets)} - Ticket {ticket.get('ticket_id')}")
                section = self.create_ticket_section(ticket, i)
                report_content.append(section)
            
            # R√©sum√© des escalades
            report_content.append(self.create_escalation_summary(tickets))
            
            # Pied de page
            report_content.append(self.create_footer())
            
            return '\n'.join(report_content)
            
        except Exception as e:
            print(f"‚ùå Erreur g√©n√©ration rapport am√©lior√©: {e}")
            return f"# Erreur\n\nErreur lors de la g√©n√©ration du rapport: {e}"

def main():
    """Fonction principale"""
    print("üìù G√âN√âRATION RAPPORT MARKDOWN AM√âLIOR√â")
    print("=" * 60)
    
    # Fichier des tickets avec escalades
    tickets_file = "/Users/r4v3n/Workspce/Prod/kikoo_rag/flowup-support-bot/data/uc336_tickets_enhanced_responses.json"
    
    # V√©rifier que le fichier existe
    if not os.path.exists(tickets_file):
        print(f"‚ùå Fichier tickets non trouv√©: {tickets_file}")
        return
    
    # Initialiser le g√©n√©rateur
    generator = EnhancedMarkdownReportGenerator()
    
    # G√©n√©rer le rapport
    print("üìù G√©n√©ration du rapport Markdown am√©lior√©...")
    report_content = generator.generate_enhanced_report(tickets_file)
    
    if not report_content:
        print("‚ùå Erreur g√©n√©ration rapport")
        return
    
    # Sauvegarder le rapport
    output_file = "/Users/r4v3n/Workspce/Prod/kikoo_rag/flowup-support-bot/data/UC_336_10_TICKETS_ESCALADES_IMMEDIATES.md"
    
    try:
        with open(output_file, 'w', encoding='utf-8') as f:
            f.write(report_content)
        
        print(f"üíæ Rapport am√©lior√© sauvegard√©: {output_file}")
        
        # R√©sum√©
        print(f"\nüìä R√âSUM√â")
        print("=" * 30)
        print(f"‚úÖ Rapport am√©lior√© g√©n√©r√© avec succ√®s")
        print(f"üìÑ Fichier: {output_file}")
        print(f"üìè Taille: {len(report_content)} caract√®res")
        
        # Statistiques
        lines = report_content.count('\n')
        print(f"üìù Lignes: {lines}")
        
        # Compter les escalades
        escalades = report_content.count('üö® ESCALADE IMM√âDIATE')
        print(f"üö® Escalades d√©tect√©es: {escalades}")
        
    except Exception as e:
        print(f"‚ùå Erreur sauvegarde: {e}")

if __name__ == "__main__":
    main()
